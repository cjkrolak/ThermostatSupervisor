---
name: Azure Pipelines
# disable CI trigger
trigger: none
# trigger on PR to dev branch only for relevant file changes
# Pipeline will check that GitHub Actions pass and code review is complete
# before running
pr:
  branches:
    include: [develop]
  paths:
    include:
      - '**/*.py'
      - .github/azure-pipelines.yml
      - .github/workflows/sonarqube.yml
pool:
  vmImage: ubuntu-latest
strategy:
  matrix:
    # rem out 3.09 thru 3.12 to save CI time
    # Python309:
    #   python.version: '3.9'
    # Python310:
    #   python.version: '3.10'
    # Python311:
    #  python.version: '3.11'
    # Python312:
    #  python.version: '3.12'
    Python313:
      python.version: '3.13'
steps:
  - task: UsePythonVersion@0
    inputs:
      versionSpec: $(python.version)
      # githubToken: $(THERMOSTATSUPERVISOR_PR)
    #  github token appears to enforce only supported python versions, ref  # 884
    # v3.13 is not supported by ubuntu-latest, once it is,
    # the github token can be enabled.
    displayName: Use Python $(python.version)
  # Check that required GitHub Actions have passed and PR has been reviewed
  - script: |
      set -e
      echo "Checking GitHub Actions status and code review requirements..."

      # Check if this is a PR build
      if [ -z "${SYSTEM_PULLREQUEST_PULLREQUESTNUMBER}" ]; then
        echo "Not a PR build, skipping checks"
        exit 0
      fi

      PR_NUMBER="${SYSTEM_PULLREQUEST_PULLREQUESTNUMBER}"
      echo "Checking PR #${PR_NUMBER}"

      # Validate GitHub token
      if [ -z "${THERMOSTATSUPERVISOR_PR}" ]; then
        echo "ERROR: THERMOSTATSUPERVISOR_PR token not configured"
        echo "This pipeline now requires GitHub Actions to pass first"
        echo "Please configure the GitHub token to check PR status"
        exit 1
      fi

      # Check required GitHub Actions status
      echo "Checking status of required GitHub Actions..."
      REQUIRED_CHECKS="Pylint,YAML Lint,CodeQL,Codacy Security Scan,OSSAR"

      # Get PR details and check status
      PR_DATA=$(curl -s -H "Authorization: token ${THERMOSTATSUPERVISOR_PR}" \
        "https://api.github.com/repos/cjkrolak/ThermostatSupervisor/pulls/${PR_NUMBER}")

      if [ $? -ne 0 ]; then
        echo "Failed to fetch PR data"
        exit 1
      fi

      # Get the latest commit SHA
      HEAD_SHA=$(echo "${PR_DATA}" | python3 -c \
        "import json,sys; data=json.load(sys.stdin); print(data['head']['sha'])")
      echo "Latest commit SHA: ${HEAD_SHA}"

      # Check status of required checks
      echo "Fetching check runs for commit ${HEAD_SHA}..."
      CHECK_RUNS=$(curl -s -H "Authorization: token ${THERMOSTATSUPERVISOR_PR}" \
        "https://api.github.com/repos/cjkrolak/ThermostatSupervisor/commits/${HEAD_SHA}/check-runs")

      if [ $? -ne 0 ]; then
        echo "Failed to fetch check runs"
        exit 1
      fi

      # Parse and verify check status
      python3 << 'EOF'
      import json
      import sys
      import os

      required_checks = os.environ.get('REQUIRED_CHECKS', '').split(',')
      required_checks = [check.strip() for check in required_checks if check.strip()]

      try:
          with open('/dev/stdin') as f:
              check_data = json.load(f)

          print(f"Found {check_data['total_count']} check runs")

          successful_checks = []
          failed_checks = []
          pending_checks = []

          for check in check_data['check_runs']:
              name = check['name']
              status = check['status']
              conclusion = check['conclusion']

              print(f"  {name}: {status} - {conclusion}")

              if status == 'completed':
                  if conclusion == 'success':
                      successful_checks.append(name)
                  else:
                      failed_checks.append(name)
              else:
                  pending_checks.append(name)

          print(f"\nSuccessful checks: {len(successful_checks)}")
          print(f"Failed checks: {len(failed_checks)}")
          print(f"Pending checks: {len(pending_checks)}")

          if failed_checks:
              failed_list = ', '.join(failed_checks)
              print(f"\nFAILED: The following checks have failed: {failed_list}")
              print("Azure DevOps pipeline will not run until all GitHub Actions pass")
              sys.exit(1)

          if pending_checks:
              pending_list = ', '.join(pending_checks)
              print(f"\nPENDING: The following checks are still running:")
              print(f"{pending_list}")
              print("Azure DevOps pipeline will wait for GitHub Actions to complete")
              sys.exit(1)

          print(f"\nâœ… All GitHub Actions have completed successfully")
          print("Proceeding with Azure DevOps pipeline...")

      except Exception as e:
          print(f"Error checking GitHub Actions status: {e}")
          print("Proceeding with caution...")
      EOF <<< "${CHECK_RUNS}"

      echo "GitHub Actions status check completed"
    displayName: Check GitHub Actions Status
    condition: always()
    env:
      THERMOSTATSUPERVISOR_PR: $(THERMOSTATSUPERVISOR_PR)
      REQUIRED_CHECKS: "Pylint,YAML Lint,CodeQL,Codacy Security Scan,OSSAR"
  - script: |
      python -m pip install --upgrade pip
      pip install -r requirements.txt
      pip list
    displayName: Install dependencies
  # line length and extend-ignore options added for compatibility with black
  - script: |
      python -m pip install flake8 --upgrade
      flake8 --config=setup.cfg .
    displayName: Run lint tests
  # python unit tests
  - script: |
      # python -m unittest discover -v
      # discover process is not allowing argv override so calling
      # unit_test_common instead.
      python -m tests.unit_test_coverage
    displayName: Unit Tests
    # timeout after 30 minutes, nominal job time is 10 minutes
    timeoutInMinutes: '30'
    env:
      GMAIL_USERNAME: $(GMAIL_USERNAME)  # used for some unit tests
      GMAIL_PASSWORD: $(GMAIL_PASSWORD)  # used for some unit test
      TCC_USERNAME: $(TCC_USERNAME)  # used for Honeywell int test
      TCC_PASSWORD: $(TCC_PASSWORD)  # used for Honeywell int test
      SHT31_REMOTE_IP_ADDRESS_1: $(SHT31_REMOTE_IP_ADDRESS_1)
      # SHT31_REMOTE_IP_ADDRESS_99: '$(SHT31_REMOTE_IP_ADDRESS_99)'
      KUMO_USERNAME: $(KUMO_USERNAME)  # used for kumocloud int test
      KUMO_PASSWORD: $(KUMO_PASSWORD)  # used for kumocloud int test
      BLINK_USERNAME: $(BLINK_USERNAME)  # used for blink int test
      BLINK_PASSWORD: $(BLINK_PASSWORD)  # used for blink int test
      BLINK_2FA: $(BLINK_2FA)  # used for blink int test
  # publish code coverage results to ADO pipeline
  - task: PublishCodeCoverageResults@2
    inputs:
      summaryFileLocation: coverage.xml
    displayName: Publish Code Coverage
  # Upload coverage.xml as GitHub artifact for SonarQube workflow
  - script: |
      set -e
      echo "Uploading coverage.xml as GitHub artifact..."

      # Validate token and file exist
      if [ -z "${THERMOSTATSUPERVISOR_PR}" ]; then
        echo "ERROR: THERMOSTATSUPERVISOR_PR is not set"
        exit 1
      fi
      if [ ! -f "coverage.xml" ]; then
        echo "ERROR: coverage.xml not found"
        exit 1
      fi
      echo "Coverage file size: $(wc -c < coverage.xml) bytes"

      # Create JSON payload using a temporary file to avoid command line length limits
      temp_json=$(mktemp)
      cat > "${temp_json}" << 'EOF'
      {
        "description": "Coverage data for SonarQube - Build BUILD_ID_PLACEHOLDER",
        "public": false,
        "files": {
          "coverage.xml": {
            "content": "CONTENT_PLACEHOLDER"
          }
        }
      }
      EOF

      # Replace placeholders with actual values
      # First replace BUILD_ID_PLACEHOLDER with actual build ID
      sed -i "s/BUILD_ID_PLACEHOLDER/$(Build.BuildId)/g" "${temp_json}"

      # Then replace CONTENT_PLACEHOLDER with properly escaped coverage.xml content
      # Use Python to properly escape JSON content to avoid shell quoting issues
      python3 -c "
      import json
      import sys

      # Read the coverage.xml content
      with open('coverage.xml', 'r') as f:
          coverage_content = f.read()

      # Read the JSON template
      with open('${temp_json}', 'r') as f:
          json_template = f.read()

      # Replace the content placeholder with properly escaped JSON string
      escaped_content = json.dumps(coverage_content)
      final_json = json_template.replace('\"CONTENT_PLACEHOLDER\"', escaped_content)

      # Write the final JSON
      with open('${temp_json}', 'w') as f:
          f.write(final_json)
      "

      # Create the GitHub gist using the JSON file
      response=$(curl -w "%{http_code}" -s -X POST \
        -H "Accept: application/vnd.github.v3+json" \
        -H "Authorization: token ${THERMOSTATSUPERVISOR_PR}" \
        -H "User-Agent: Azure-DevOps-Pipeline" \
        -H "Content-Type: application/json" \
        https://api.github.com/gists \
        --data-binary "@${temp_json}")

      # Clean up temporary file
      rm -f "${temp_json}"

      # Extract HTTP status code and response body
      http_code="${response: -3}"
      response_body="${response%???}"
      if [[ ${http_code} -ge 200 && ${http_code} -lt 300 ]]; then
        # Extract gist ID from response
        gist_id=$(echo "${response_body}" | grep -o '"id":"[^"]*"' | head -1 |
        cut -d'"' -f4)
        echo "SUCCESS: Coverage uploaded successfully to gist: ${gist_id}"
        echo "##vso[task.setvariable variable=coverageGistId;isOutput=true]${gist_id}"
      else
        echo "ERROR: Failed to upload coverage. HTTP ${http_code}"
        echo "Response: ${response_body}"
        exit 1
      fi
    name: uploadCoverage
    displayName: Upload Coverage Data
    condition: succeeded()
    env:
      THERMOSTATSUPERVISOR_PR: $(THERMOSTATSUPERVISOR_PR)
  # trigger SonarQube workflow on successful completion
  - script: |
      set -e  # Exit on any error
      echo "Triggering SonarQube workflow..."

      # Validate token is present
      if [ -z "${THERMOSTATSUPERVISOR_PR}" ]; then
        echo "ERROR: THERMOSTATSUPERVISOR_PR is not set"
        echo ""
        echo "SETUP: SETUP INSTRUCTIONS:"
        echo "1. Go to Azure DevOps > Pipelines > Library > Variable groups"
        echo "2. Create/edit the variable group used by this pipeline"
        echo "3. Add variable: THERMOSTATSUPERVISOR_PR"
        echo "4. Value should be a GitHub Personal Access Token (classic)
        with these scopes:"
        echo "   - repo (for private repos) OR public_repo (for public repos)"
        echo "   - workflow (to trigger workflow dispatches)"
        echo "5. Mark the variable as secret in Azure DevOps"
        echo ""
        echo "LINK: Create token at: https://github.com/settings/tokens"
        exit 1
      fi
      echo "THERMOSTATSUPERVISOR_PR is configured
      (${#THERMOSTATSUPERVISOR_PR} characters)"

      # Test basic GitHub API access first
      echo "Testing GitHub API access..."
      test_response=$(curl -w "%{http_code}" -s \
        -H "Authorization: token ${THERMOSTATSUPERVISOR_PR}" \
        https://api.github.com/user)
      test_code="${test_response: -3}"
      if [[ ${test_code} -ne 200 ]]; then
        echo "ERROR: GitHub API authentication failed (HTTP ${test_code})"
        echo "The THERMOSTATSUPERVISOR_PR is invalid or expired"
        echo ""
        echo "SETUP: TOKEN TROUBLESHOOTING:"
        echo "1. Verify the token at: https://github.com/settings/tokens"
        echo "2. Check if the token has expired"
        echo "3. Ensure the token has 'repo' and 'workflow' scopes"
        echo "4. The token must belong to a user with push access to the repository"
        exit 1
      fi
      echo "SUCCESS: GitHub API authentication successful"

      # Get the coverage gist ID from previous step (if available)
      coverage_gist_id="$(uploadCoverage.coverageGistId)"
      echo "Coverage gist ID: ${coverage_gist_id}"

      # Create JSON payload
      json_payload='{"event_type":"azure-pipeline-completed","client_payload":{"result":"success","run_id":"'$(Build.BuildId)'","coverage_gist_id":"'${coverage_gist_id}'"}}'

      # Make the API request with detailed error handling
      echo "Triggering repository dispatch event..."
      response=$(curl -w "%{http_code}" -s -X POST \
        -H "Accept: application/vnd.github.v3+json" \
        -H "Authorization: token ${THERMOSTATSUPERVISOR_PR}" \
        -H "User-Agent: Azure-DevOps-Pipeline" \
        https://api.github.com/repos/cjkrolak/ThermostatSupervisor/dispatches \
        -d "${json_payload}")

      # Extract HTTP status code (last 3 characters)
      http_code="${response: -3}"
      response_body="${response%???}"
      echo "HTTP Response Code: ${http_code}"
      if [ -n "${response_body}" ]; then
        echo "Response Body: ${response_body}"
      fi

      # Check if the request was successful (2xx status codes)
      if [[ ${http_code} -ge 200 && ${http_code} -lt 300 ]]; then
        echo "SUCCESS: Successfully triggered SonarQube workflow"
        exit 0
      elif [[ ${http_code} -eq 401 ]]; then
        echo "ERROR: ERROR: Authentication failed (HTTP 401)"
        echo ""
        echo "SETUP: TOKEN PERMISSIONS ISSUE:"
        echo "The THERMOSTATSUPERVISOR_PR lacks required permissions for
        workflow dispatches"
        echo ""
        echo "Required token scopes:"
        echo "  - repo (for private repositories)"
        echo "  - workflow (to trigger repository dispatch events)"
        echo ""
        echo "Update token at: https://github.com/settings/tokens"
        echo "Response: ${response_body}"
        exit 1
      elif [[ ${http_code} -eq 403 ]]; then
        echo "ERROR: ERROR: Forbidden (HTTP 403)"
        echo "The token user lacks push access to the repository or token
        scopes insufficient"
        echo ""
        echo "Required:"
        echo "  - Token owner must have push access to cjkrolak/ThermostatSupervisor"
        echo "  - Token must have 'repo' and 'workflow' scopes"
        echo "Response: ${response_body}"
        exit 1
      elif [[ ${http_code} -eq 404 ]]; then
        echo "ERROR: ERROR: Repository not found (HTTP 404)"
        echo "Check repository name or ensure token has access to the repository"
        echo "Response: ${response_body}"
        exit 1
      else
        echo "ERROR: ERROR: Failed to trigger SonarQube workflow. HTTP ${http_code}"
        echo "Response: ${response_body}"
        exit 1
      fi
    displayName: Trigger SonarQube Workflow
    condition: succeeded()
    env:
      THERMOSTATSUPERVISOR_PR: $(THERMOSTATSUPERVISOR_PR)
      # Azure DevOps pipeline variable - must be Personal Access Token
      # with 'repo' and 'workflow' scopes
